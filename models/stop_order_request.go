// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StopOrderRequest A StopOrderRequest specifies the parameters that may be set when creating a Stop Order.
// swagger:model StopOrderRequest
type StopOrderRequest struct {

	// client extensions
	ClientExtensions *ClientExtensions `json:"clientExtensions,omitempty"`

	// The date/time when the Stop Order will be cancelled if its timeInForce is "GTD".
	GtdTime string `json:"gtdTime,omitempty"`

	// The Stop Order's Instrument.
	Instrument string `json:"instrument,omitempty"`

	// Specification of how Positions in the Account are modified when the Order is filled.
	// Enum: [OPEN_ONLY REDUCE_FIRST REDUCE_ONLY DEFAULT]
	PositionFill string `json:"positionFill,omitempty"`

	// The price threshold specified for the Stop Order. The Stop Order will only be filled by a market price that is equal to or worse than this price.
	Price string `json:"price,omitempty"`

	// The worst market price that may be used to fill this Stop Order. If the market gaps and crosses through both the price and the priceBound, the Stop Order will be cancelled instead of being filled.
	PriceBound string `json:"priceBound,omitempty"`

	// stop loss on fill
	StopLossOnFill *StopLossDetails `json:"stopLossOnFill,omitempty"`

	// take profit on fill
	TakeProfitOnFill *TakeProfitDetails `json:"takeProfitOnFill,omitempty"`

	// The time-in-force requested for the Stop Order.
	// Enum: [GTC GTD GFD FOK IOC]
	TimeInForce string `json:"timeInForce,omitempty"`

	// trade client extensions
	TradeClientExtensions *ClientExtensions `json:"tradeClientExtensions,omitempty"`

	// trailing stop loss on fill
	TrailingStopLossOnFill *TrailingStopLossDetails `json:"trailingStopLossOnFill,omitempty"`

	// Specification of which price component should be used when determining if an Order should be triggered and filled. This allows Orders to be triggered based on the bid, ask, mid, default (ask for buy, bid for sell) or inverse (ask for sell, bid for buy) price depending on the desired behaviour. Orders are always filled using their default price component.
	// This feature is only provided through the REST API. Clients who choose to specify a non-default trigger condition will not see it reflected in any of OANDA's proprietary or partner trading platforms, their transaction history or their account statements. OANDA platforms always assume that an Order's trigger condition is set to the default value when indicating the distance from an Order's trigger price, and will always provide the default trigger condition when creating or modifying an Order.
	// A special restriction applies when creating a guaranteed Stop Loss Order. In this case the TriggerCondition value must either be "DEFAULT", or the "natural" trigger side "DEFAULT" results in. So for a Stop Loss Order for a long trade valid values are "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
	// Enum: [DEFAULT INVERSE BID ASK MID]
	TriggerCondition string `json:"triggerCondition,omitempty"`

	// The type of the Order to Create. Must be set to "STOP" when creating a Stop Order.
	// Enum: [MARKET LIMIT STOP MARKET_IF_TOUCHED TAKE_PROFIT STOP_LOSS TRAILING_STOP_LOSS FIXED_PRICE]
	Type string `json:"type,omitempty"`

	// The quantity requested to be filled by the Stop Order. A posititive number of units results in a long Order, and a negative number of units results in a short Order.
	Units string `json:"units,omitempty"`
}

// Validate validates this stop order request
func (m *StopOrderRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientExtensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePositionFill(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStopLossOnFill(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTakeProfitOnFill(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeInForce(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTradeClientExtensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTrailingStopLossOnFill(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggerCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StopOrderRequest) validateClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientExtensions) { // not required
		return nil
	}

	if m.ClientExtensions != nil {
		if err := m.ClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clientExtensions")
			}
			return err
		}
	}

	return nil
}

var stopOrderRequestTypePositionFillPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OPEN_ONLY","REDUCE_FIRST","REDUCE_ONLY","DEFAULT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypePositionFillPropEnum = append(stopOrderRequestTypePositionFillPropEnum, v)
	}
}

const (

	// StopOrderRequestPositionFillOPENONLY captures enum value "OPEN_ONLY"
	StopOrderRequestPositionFillOPENONLY string = "OPEN_ONLY"

	// StopOrderRequestPositionFillREDUCEFIRST captures enum value "REDUCE_FIRST"
	StopOrderRequestPositionFillREDUCEFIRST string = "REDUCE_FIRST"

	// StopOrderRequestPositionFillREDUCEONLY captures enum value "REDUCE_ONLY"
	StopOrderRequestPositionFillREDUCEONLY string = "REDUCE_ONLY"

	// StopOrderRequestPositionFillDEFAULT captures enum value "DEFAULT"
	StopOrderRequestPositionFillDEFAULT string = "DEFAULT"
)

// prop value enum
func (m *StopOrderRequest) validatePositionFillEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypePositionFillPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validatePositionFill(formats strfmt.Registry) error {

	if swag.IsZero(m.PositionFill) { // not required
		return nil
	}

	// value enum
	if err := m.validatePositionFillEnum("positionFill", "body", m.PositionFill); err != nil {
		return err
	}

	return nil
}

func (m *StopOrderRequest) validateStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.StopLossOnFill) { // not required
		return nil
	}

	if m.StopLossOnFill != nil {
		if err := m.StopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stopLossOnFill")
			}
			return err
		}
	}

	return nil
}

func (m *StopOrderRequest) validateTakeProfitOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TakeProfitOnFill) { // not required
		return nil
	}

	if m.TakeProfitOnFill != nil {
		if err := m.TakeProfitOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("takeProfitOnFill")
			}
			return err
		}
	}

	return nil
}

var stopOrderRequestTypeTimeInForcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GTC","GTD","GFD","FOK","IOC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypeTimeInForcePropEnum = append(stopOrderRequestTypeTimeInForcePropEnum, v)
	}
}

const (

	// StopOrderRequestTimeInForceGTC captures enum value "GTC"
	StopOrderRequestTimeInForceGTC string = "GTC"

	// StopOrderRequestTimeInForceGTD captures enum value "GTD"
	StopOrderRequestTimeInForceGTD string = "GTD"

	// StopOrderRequestTimeInForceGFD captures enum value "GFD"
	StopOrderRequestTimeInForceGFD string = "GFD"

	// StopOrderRequestTimeInForceFOK captures enum value "FOK"
	StopOrderRequestTimeInForceFOK string = "FOK"

	// StopOrderRequestTimeInForceIOC captures enum value "IOC"
	StopOrderRequestTimeInForceIOC string = "IOC"
)

// prop value enum
func (m *StopOrderRequest) validateTimeInForceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypeTimeInForcePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validateTimeInForce(formats strfmt.Registry) error {

	if swag.IsZero(m.TimeInForce) { // not required
		return nil
	}

	// value enum
	if err := m.validateTimeInForceEnum("timeInForce", "body", m.TimeInForce); err != nil {
		return err
	}

	return nil
}

func (m *StopOrderRequest) validateTradeClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.TradeClientExtensions) { // not required
		return nil
	}

	if m.TradeClientExtensions != nil {
		if err := m.TradeClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tradeClientExtensions")
			}
			return err
		}
	}

	return nil
}

func (m *StopOrderRequest) validateTrailingStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TrailingStopLossOnFill) { // not required
		return nil
	}

	if m.TrailingStopLossOnFill != nil {
		if err := m.TrailingStopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("trailingStopLossOnFill")
			}
			return err
		}
	}

	return nil
}

var stopOrderRequestTypeTriggerConditionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEFAULT","INVERSE","BID","ASK","MID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypeTriggerConditionPropEnum = append(stopOrderRequestTypeTriggerConditionPropEnum, v)
	}
}

const (

	// StopOrderRequestTriggerConditionDEFAULT captures enum value "DEFAULT"
	StopOrderRequestTriggerConditionDEFAULT string = "DEFAULT"

	// StopOrderRequestTriggerConditionINVERSE captures enum value "INVERSE"
	StopOrderRequestTriggerConditionINVERSE string = "INVERSE"

	// StopOrderRequestTriggerConditionBID captures enum value "BID"
	StopOrderRequestTriggerConditionBID string = "BID"

	// StopOrderRequestTriggerConditionASK captures enum value "ASK"
	StopOrderRequestTriggerConditionASK string = "ASK"

	// StopOrderRequestTriggerConditionMID captures enum value "MID"
	StopOrderRequestTriggerConditionMID string = "MID"
)

// prop value enum
func (m *StopOrderRequest) validateTriggerConditionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypeTriggerConditionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validateTriggerCondition(formats strfmt.Registry) error {

	if swag.IsZero(m.TriggerCondition) { // not required
		return nil
	}

	// value enum
	if err := m.validateTriggerConditionEnum("triggerCondition", "body", m.TriggerCondition); err != nil {
		return err
	}

	return nil
}

var stopOrderRequestTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MARKET","LIMIT","STOP","MARKET_IF_TOUCHED","TAKE_PROFIT","STOP_LOSS","TRAILING_STOP_LOSS","FIXED_PRICE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypeTypePropEnum = append(stopOrderRequestTypeTypePropEnum, v)
	}
}

const (

	// StopOrderRequestTypeMARKET captures enum value "MARKET"
	StopOrderRequestTypeMARKET string = "MARKET"

	// StopOrderRequestTypeLIMIT captures enum value "LIMIT"
	StopOrderRequestTypeLIMIT string = "LIMIT"

	// StopOrderRequestTypeSTOP captures enum value "STOP"
	StopOrderRequestTypeSTOP string = "STOP"

	// StopOrderRequestTypeMARKETIFTOUCHED captures enum value "MARKET_IF_TOUCHED"
	StopOrderRequestTypeMARKETIFTOUCHED string = "MARKET_IF_TOUCHED"

	// StopOrderRequestTypeTAKEPROFIT captures enum value "TAKE_PROFIT"
	StopOrderRequestTypeTAKEPROFIT string = "TAKE_PROFIT"

	// StopOrderRequestTypeSTOPLOSS captures enum value "STOP_LOSS"
	StopOrderRequestTypeSTOPLOSS string = "STOP_LOSS"

	// StopOrderRequestTypeTRAILINGSTOPLOSS captures enum value "TRAILING_STOP_LOSS"
	StopOrderRequestTypeTRAILINGSTOPLOSS string = "TRAILING_STOP_LOSS"

	// StopOrderRequestTypeFIXEDPRICE captures enum value "FIXED_PRICE"
	StopOrderRequestTypeFIXEDPRICE string = "FIXED_PRICE"
)

// prop value enum
func (m *StopOrderRequest) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StopOrderRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StopOrderRequest) UnmarshalBinary(b []byte) error {
	var res StopOrderRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
